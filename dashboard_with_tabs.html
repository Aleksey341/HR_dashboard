Chart.register(ChartDataLabels);
    const qMap = JSON.parse(document.getElementById('qMapData')?.textContent || '{}');
    const currentPythonYear = JSON.parse(document.getElementById('currentYearData')?.textContent || '0');
    const maxItemsForChartGlobal = JSON.parse(document.getElementById('antiTopChartItems')?.textContent || '10');
    const tomSelects = {};
    const activeCharts = {}; // Эта строка важна, не комментируйте ее

    function destroyChartIfExists(chartId) {
        if (activeCharts[chartId]) {
            activeCharts[chartId].destroy();
            delete activeCharts[chartId];
        }
    }

 function updateAntiTopCharts(tabIdx) {
     console.log(`Attempting to update charts for tab: ${tabIdx}`);
     const table = document.getElementById(`table-${tabIdx}`);
     const turnoverChartId = `turnoverChart_${tabIdx}`, staffingChartId = `staffingChart_${tabIdx}`;
     const turnoverCanvas = document.getElementById(turnoverChartId), staffingCanvas = document.getElementById(staffingChartId);

     destroyChartIfExists(turnoverChartId);
     destroyChartIfExists(staffingChartId);

     if (!table || !turnoverCanvas || !staffingCanvas) {
         return;
     }

     const visibleRows = Array.from(table.querySelectorAll('tbody tr')).filter(row => row.style.display !== 'none' && row.cells.length > 1 && !row.querySelector('td[colspan="100%"]'));
     if (visibleRows.length === 0) {
        turnoverCanvas.getContext('2d').clearRect(0, 0, turnoverCanvas.width, turnoverCanvas.height);
        staffingCanvas.getContext('2d').clearRect(0, 0, staffingCanvas.width, staffingCanvas.height);
        return;
    }

     const labels = [], turnoverData = [], staffingData = [];
     visibleRows.slice(0, maxItemsForChartGlobal).forEach(row => {
         const branchName = row.cells[1] ? row.cells[1].textContent.trim() : 'N/A';
         const rawTurnover = parseFloat(row.dataset.turnoverRaw);
         const rawStaffing = parseFloat(row.dataset.staffingRaw);
        labels.push(branchName);
         turnoverData.push(isNaN(rawTurnover) ? 0 : rawTurnover);
        staffingData.push(isNaN(rawStaffing) ? 0 : rawStaffing);
    });

     if (labels.length === 0) {
         return;
    }

     const chartOptionsGen = (yLabel, isPercent = true, maxVal = undefined) => ({
         responsive: true,
         maintainAspectRatio: false,
         animation: {
             duration: 0
       },
        scales: {
             y: {
                 beginAtZero: true,
                 max: maxVal,
                 ticks: {
                     callback: value => (isPercent ? (value * 100).toFixed(0) + '%' : value.toFixed(1)),
                     color: document.body.classList.contains('dim') ? '#f0f0f0' : '#333'
                 },
                 grid: {
                     color: document.body.classList.contains('dim') ? '#555' : '#e0e0e0'
                 }
            },
             x: {
                 ticks: {
                     color: document.body.classList.contains('dim') ? '#f0f0f0' : '#333',
                     autoSkip: true,
                     maxRotation: 45,
                     minRotation: 0
                 },
                 grid: {
                     display: false
                 }
             }
         },
         plugins: {
            legend: {
                display: false,
                 labels: {
                     color: document.body.classList.contains('dim') ? '#f0f0f0' : '#333'
                 }
             },
             tooltip: {
                 callbacks: {
                     label: context => `${yLabel}: ${isPercent ? (context.raw * 100).toFixed(1) + '%' : context.raw.toFixed(1)}`
                 }
             },
            datalabels: {
                anchor: 'end',
                align: 'top',
                formatter: (value) => isPercent ? (value * 100).toFixed(1) + '%' : value.toFixed(1),
                font: {
                    weight: 'bold'
                },
                color: document.body.classList.contains('dim') ? '#f0f0f0' : '#333'
             }
        }
    });

    activeCharts[turnoverChartId] = new Chart(turnoverCanvas.getContext('2d'), {
        type: 'bar',
        data: {
            labels: labels,
            datasets: [{
                 label: 'Текучесть',
                data: turnoverData,
                backgroundColor: 'rgba(215, 38, 61, 0.6)',
                borderColor: 'rgba(215, 38, 61, 1)',
                borderWidth: 1,
                barPercentage: 0.7,
                categoryPercentage: 0.8
            }]
         },
         options: chartOptionsGen('Текучесть', true),
         plugins: [ChartDataLabels]
     });

     activeCharts[staffingChartId] = new Chart(staffingCanvas.getContext('2d'), {
        type: 'bar',
         data: {
             labels: labels,
             datasets: [{
                 label: 'Укомплектованность',
                 data: staffingData,
                 backgroundColor: 'rgba(29, 114, 184, 0.6)',
                 borderColor: 'rgba(29, 114, 184, 1)',
                 borderWidth: 1,
                 barPercentage: 0.7,
                 categoryPercentage: 0.8  // ИСПРАВЛЕН ОШИБОЧНЫЙ КОММЕНТАРИЙ ЗДЕСЬ (было / categoryPercentage)
            }]
        },   
        options: chartOptionsGen('Укомплект.', true, 1.05),
         plugins: [ChartDataLabels]
     });
 } 

    document.addEventListener('DOMContentLoaded', () => {
        document.querySelectorAll('.tabbar .tab').forEach(tabButton => {
            tabButton.addEventListener('click', () => {
                if (tabButton.classList.contains('active')) return;
                document.querySelectorAll('.tabbar .tab.active').forEach(btn => btn.classList.remove('active'));
                tabButton.classList.add('active');
                document.querySelectorAll('.page').forEach(page => page.style.display = 'none');
                const targetPage = document.getElementById(tabButton.dataset.target);
                if (targetPage) {
                    targetPage.style.display = 'block';
                    const tabIdx = tabButton.dataset.target.replace('tab', '');
                    applyTableFilters(tabIdx);
                    const kpiKlsMatch = targetPage.querySelector('.tbl')?.className.match(/tbl-kpi-([a-zA-Z0-9_]+)/);
                    if (kpiKlsMatch && (kpiKlsMatch[1] === 'anti_top_year' || kpiKlsMatch[1] === 'monthly_anti_top')) {
                        // Если updateAntiTopCharts закомментирована, эта строка вызовет ошибку или ничего не сделает
                         setTimeout(() => updateAntiTopCharts(tabIdx), 200);
                    } else {
                         destroyChartIfExists(`turnoverChart_${tabIdx}`); // Также может вызвать ошибку, если функция закомментирована
                         destroyChartIfExists(`staffingChart_${tabIdx}`);
                    }
                    setTimeout(() => fitAndHideColumns(tabIdx), 250);
                }
            });
        });

        document.querySelectorAll('select.sel_branch, select.sel_year, select.sel_quarter, select.sel_month, select.sel_year_monthly_antitop, select.sel_month_monthly_antitop').forEach(selectEl => {
            const tabIdx = selectEl.dataset.tabIdx;
            const filterType = selectEl.dataset.filterType;
            const kpiKlsFromAttr = selectEl.dataset.kpiKls;
            if (!tomSelects[tabIdx]) tomSelects[tabIdx] = {};
            if (!tomSelects[tabIdx][filterType]) {
                tomSelects[tabIdx][filterType] = new TomSelect(selectEl, {
                    plugins: selectEl.multiple ? ['remove_button'] : [],
                    persist: false,
                    allowEmptyOption: true,
                    onChange: function() {
                        applyTableFilters(tabIdx);
                    }
                });
                if (filterType === 'year' && currentPythonYear !== 0 && (kpiKlsFromAttr === 'turn' || kpiKlsFromAttr === 'staff' || kpiKlsFromAttr === 'other')) {
                    if (Array.from(selectEl.options).some(opt => opt.value == currentPythonYear.toString())) {
                        setTimeout(() => {
                            if (tomSelects[tabIdx]?.[filterType]) {
                                tomSelects[tabIdx][filterType].setValue(currentPythonYear.toString(), false);
                            }
                        }, 100);
                    }
                }
            }
        });

        document.querySelectorAll('.chk_antitop').forEach(chk => {
            chk.addEventListener('change', () => {
                applyTableFilters(chk.dataset.tabIdx);
            });
        });

        const firstActiveTab = document.querySelector('.tabbar .tab.active');
        if (firstActiveTab) {
            const firstTabIdx = firstActiveTab.dataset.target.replace('tab', '');
            applyTableFilters(firstTabIdx);
            const firstPage = document.getElementById(firstActiveTab.dataset.target);
            if (firstPage) {
                const kpiMatch = firstPage.querySelector('.tbl')?.className.match(/tbl-kpi-([a-zA-Z0-9_]+)/);
                if (kpiMatch && (kpiMatch[1] === 'anti_top_year' || kpiMatch[1] === 'monthly_anti_top')) {
                     // Если updateAntiTopCharts закомментирована, эта строка вызовет ошибку или ничего не сделает
                     setTimeout(() => updateAntiTopCharts(firstTabIdx), 300);
                }
            }
            setTimeout(() => fitAndHideColumns(firstTabIdx), 350);
        }
    });

    function fitAndHideColumns(tabIdx) {
        const table = document.getElementById(`table-${tabIdx}`);
        if (!table) return;
        fitFirstColumns(table);
        if (!table.classList.contains('tbl-kpi-anti_top_year') &&
            !table.classList.contains('tbl-kpi-monthly_anti_top') &&
            !table.classList.contains('tbl-kpi-enps')) {
            hideEmptyDataColumns(table);
        }
    }

    function fitFirstColumns(table) {
        if (!table) return;
        const isAntiTop = table.classList.contains('tbl-kpi-anti_top_year') || table.classList.contains('tbl-kpi-monthly_anti_top');
        const firstColSelector = 'td:first-child, th:first-child';
        const secondColSelector = 'td:nth-child(2), th:nth-child(2)';
        const firstColCells = [...table.querySelectorAll(firstColSelector)];
        const secondColCells = isAntiTop ? [...table.querySelectorAll(secondColSelector)] : [];

        if (!firstColCells.length) return;
        const visibleRows = [...table.querySelectorAll('tbody tr')].filter(r => r.style.display !== 'none');
        let firstColMaxWidth = isAntiTop ? 50 : 180;
        const firstCellsInVisibleRows = visibleRows.map(r => r.cells[0]).filter(Boolean);

        if (firstCellsInVisibleRows.length > 0) {
            firstColMaxWidth = Math.max(firstColMaxWidth, ...firstCellsInVisibleRows.map(cell => cell.scrollWidth));
        } else {
            const thWidth = table.querySelector(`thead ${firstColSelector}`)?.scrollWidth;
            if (thWidth) firstColMaxWidth = Math.max(firstColMaxWidth, thWidth);
        }
        const firstColFinalWidth = Math.max(firstColMaxWidth, (isAntiTop ? 45 : 150)) + 5;
        firstColCells.forEach(cell => { cell.style.width = `${firstColFinalWidth}px`; cell.style.minWidth = `${firstColFinalWidth}px`; });

        if (isAntiTop && secondColCells.length > 0) {
            let secondColMaxWidth = 180;
            const secondCellsInVisibleRows = visibleRows.map(r => r.cells[1]).filter(Boolean);
            if (secondCellsInVisibleRows.length > 0) {
                secondColMaxWidth = Math.max(secondColMaxWidth, ...secondCellsInVisibleRows.map(cell => cell.scrollWidth));
            } else {
                const thWidth = table.querySelector(`thead ${secondColSelector}`)?.scrollWidth;
                if (thWidth) secondColMaxWidth = Math.max(secondColMaxWidth, thWidth);
            }
            const secondColFinalWidth = Math.max(secondColMaxWidth, 150) + 5;
            secondColCells.forEach(cell => { cell.style.width = `${secondColFinalWidth}px`; cell.style.minWidth = `${secondColFinalWidth}px`; cell.style.left = `${firstColFinalWidth}px`; });
        }
    }

    function hideEmptyDataColumns(table) {
        if (!table || table.classList.contains('tbl-kpi-enps') || table.classList.contains('tbl-kpi-anti_top_year') || table.classList.contains('tbl-kpi-monthly_anti_top')) return;
        const headerCells = [...table.querySelectorAll('thead th.data-col')];
        const bodyRows = [...table.querySelectorAll('tbody tr')].filter(r => r.style.display !== 'none' && !r.querySelector('td[colspan="100%"]'));

        headerCells.forEach((th) => {
            if (th.style.display === 'none') return;
            const colIdx = [...th.parentNode.children].indexOf(th);
            let columnHasVisibleData = false;
            if (bodyRows.length > 0) {
                for (const row of bodyRows) {
                    const cell = row.cells[colIdx];
                    if (cell && cell.style.display !== 'none' && cell.classList.contains('data-cell')) {
                        const text = cell.textContent.trim();
                        if (text !== '' && text !== '·' && text !== '-') { columnHasVisibleData = true; break; }
                    }
                }
            } else {
                columnHasVisibleData = true;
            }
            if (!columnHasVisibleData) {
                th.style.display = 'none';
                table.querySelectorAll(`tbody tr td:nth-child(${colIdx + 1}).data-cell`).forEach(td => td.style.display = 'none');
            }
        });
    }

    function applyTableFilters(tabIdx) {
        const page = document.getElementById(`tab${tabIdx}`);
        const table = document.getElementById(`table-${tabIdx}`);
        if (!table || !page) return;
        const tbody = table.querySelector('tbody');
        if (!tbody) return;

        const kpiKlsMatch = table.className.match(/tbl-kpi-([a-zA-Z0-9_]+)/);
        const kpiKls = kpiKlsMatch ? kpiKlsMatch[1] : 'other';

        const selectedBranches = tomSelects[tabIdx]?.['branch']?.getValue() || [];
        let selectedYearsStd = (tomSelects[tabIdx]?.['year']?.getValue() || []).map(y => y.toString());
        let selectedQuartersStd = tomSelects[tabIdx]?.['quarter']?.getValue() || [];
        let selectedMonthsStd = tomSelects[tabIdx]?.['month']?.getValue() || [];

        let yearValMAT = tomSelects[tabIdx]?.['year_monthly']?.getValue();
        let selectedYearMonthlyAntiTop = yearValMAT ? [yearValMAT.toString()] : [];
        let monthValMAT = tomSelects[tabIdx]?.['month_monthly']?.getValue();
        let selectedMonthMonthlyAntiTop = monthValMAT ? [monthValMAT] : [];

        const showTopProblematic = page.querySelector(`.chk_antitop[data-tab-idx='${tabIdx}']`)?.checked || false;
        let visibleRowsCount = 0;
        let firstVisibleMonth = null, firstVisibleYear = null, allMonthsSame = true, allYearsSame = true;

        [...tbody.querySelectorAll('tr')].forEach(row => {
            if (row.querySelector('td[colspan="100%"]')) {
                row.style.display = 'none';
                return;
            }
            const branchData = row.dataset.branch, yearData = row.dataset.year, monthData = row.dataset.month;
            let branchMatch = (kpiKls === 'anti_top_year' || kpiKls === 'enps') ? true : !selectedBranches.length || (branchData && selectedBranches.includes(branchData));
            let yearMatch = true, monthMatch = true;

            if (kpiKls === 'monthly_anti_top') {
                yearMatch = !selectedYearMonthlyAntiTop.length || (yearData && selectedYearMonthlyAntiTop.includes(yearData));
                monthMatch = !selectedMonthMonthlyAntiTop.length || (monthData && selectedMonthMonthlyAntiTop.includes(monthData));
            } else if (kpiKls !== 'enps' && kpiKls !== 'anti_top_year') {
                yearMatch = !selectedYearsStd.length || (yearData && selectedYearsStd.includes(yearData));
            }

            if (branchMatch && yearMatch && monthMatch) {
                row.style.display = '';
                visibleRowsCount++;
                if (kpiKls === 'monthly_anti_top') {
                    if (firstVisibleMonth === null && monthData) firstVisibleMonth = monthData;
                    else if (monthData && firstVisibleMonth !== monthData) allMonthsSame = false;
                    if (firstVisibleYear === null && yearData) firstVisibleYear = yearData;
                    else if (yearData && firstVisibleYear !== yearData) allYearsSame = false;
                }
            } else {
                row.style.display = 'none';
            }
        });

        if (kpiKls !== 'enps' && kpiKls !== 'anti_top_year' && kpiKls !== 'monthly_anti_top') {
            const thElements = Array.from(table.querySelectorAll('thead th'));
            const activeMonths = new Set(selectedMonthsStd);
            if (selectedQuartersStd.length > 0) {
                selectedQuartersStd.forEach(q => {
                    if (qMap[q]) qMap[q].forEach(m => activeMonths.add(m));
                });
            }
            const filterBySpecificMonthOrQuarter = selectedMonthsStd.length > 0 || selectedQuartersStd.length > 0;
            const filterBySpecificQuarter = selectedQuartersStd.length > 0;

            thElements.forEach((th, colIdx) => {
                th.style.display = '';
                table.querySelectorAll(`tbody tr td:nth-child(${colIdx + 1})`).forEach(td => {
                    if (td.parentElement.style.display !== 'none') td.style.display = '';
                });

                let hideCol = false;
                const monthClassName = Array.from(th.classList).find(cls => cls.startsWith('month-'));
                const quarterClassName = Array.from(th.classList).find(cls => cls.startsWith('quarter-'));

                if (monthClassName) {
                    const monthName = monthClassName.substring("month-".length);
                    if (filterBySpecificMonthOrQuarter && !activeMonths.has(monthName)) {
                        hideCol = true;
                    }
                } else if (quarterClassName) {
                    const quarterName = quarterClassName.substring("quarter-".length);
                    if (filterBySpecificQuarter && !selectedQuartersStd.includes(quarterName)) {
                        hideCol = true;
                    }
                }
                if (hideCol) {
                    th.style.display = 'none';
                    table.querySelectorAll(`tbody tr td:nth-child(${colIdx + 1})`).forEach(td => td.style.display = 'none');
                }
            });
        }

        if (showTopProblematic && (kpiKls === 'turn' || kpiKls === 'staff')) {
            let K = 10;
            const allCurrentVisibleRows = Array.from(tbody.querySelectorAll('tr')).filter(row => row.style.display !== 'none' && !row.querySelector('td[colspan="100%"]'));

            if (allCurrentVisibleRows.length > K) {
                allCurrentVisibleRows.sort((rowA, rowB) => {
                    const valA_str = rowA.dataset.forecastRaw;
                    const valB_str = rowB.dataset.forecastRaw;
                    const valA = (valA_str !== undefined && valA_str !== null && valA_str !== "") ? parseFloat(valA_str) : NaN;
                    const valB = (valB_str !== undefined && valB_str !== null && valB_str !== "") ? parseFloat(valB_str) : NaN;

                    if (isNaN(valA) && isNaN(valB)) return 0;
                    if (isNaN(valA)) return 1;
                    if (isNaN(valB)) return -1;

                    if (kpiKls === 'turn') {
                        return valB - valA;
                    } else if (kpiKls === 'staff') {
                        return valA - valB;
                    }
                    return 0;
                });
                allCurrentVisibleRows.forEach((row, index) => {
                    if (index >= K) {
                        row.style.display = 'none';
                    }
                });
                visibleRowsCount = allCurrentVisibleRows.filter(row => row.style.display !== 'none').length;
            }
        }

        const noDataRow = tbody.querySelector('tr td[colspan="100%"]');
        if (noDataRow) noDataRow.closest('tr').style.display = visibleRowsCount === 0 ? '' : 'none';

        const monthlyDescEl = document.getElementById(`monthly_desc_${tabIdx}`);
        const monthlyPeriodInfoEl = document.getElementById(`monthly_antitop_active_period_${tabIdx}`);
        if (kpiKls === 'monthly_anti_top' && monthlyDescEl && monthlyPeriodInfoEl) {
            let periodText = "все доступные периоды";
            if (selectedYearMonthlyAntiTop.length === 1 && selectedMonthMonthlyAntiTop.length === 1) periodText = `${selectedMonthMonthlyAntiTop[0]} ${selectedYearMonthlyAntiTop[0]}`;
            else if (visibleRowsCount > 0 && allYearsSame && allMonthsSame && firstVisibleYear && firstVisibleMonth && selectedYearMonthlyAntiTop.length === 0 && selectedMonthMonthlyAntiTop.length === 0) periodText = `${firstVisibleMonth} ${firstVisibleYear}`;
            else if (selectedYearMonthlyAntiTop.length === 1 && selectedMonthMonthlyAntiTop.length === 0) periodText = `весь ${selectedYearMonthlyAntiTop[0]} год`;
            else if (selectedYearMonthlyAntiTop.length === 0 && selectedMonthMonthlyAntiTop.length === 1) periodText = `${selectedMonthMonthlyAntiTop[0]} (все доступные года)`;
            else if (selectedYearMonthlyAntiTop.length > 0 || selectedMonthMonthlyAntiTop.length > 0) periodText = "выбранные периоды";
            monthlyDescEl.innerHTML = ("{{ monthly_anti_top_description | safe }}").replace("{{ display_period_placeholder }}", periodText);
            monthlyPeriodInfoEl.textContent = `АнтиТОП за: ${periodText}`;
        }

        if (kpiKls === 'anti_top_year' || kpiKls === 'monthly_anti_top') {
             // Если updateAntiTopCharts закомментирована, эта строка вызовет ошибку или ничего не сделает
            updateAntiTopCharts(tabIdx);
        }
    }

    function resetTableFilters(tabIdx) {
        if (tomSelects[tabIdx]) {
            Object.values(tomSelects[tabIdx]).forEach(ts => { if (ts) ts.clear(true); });
        }
        const chk = document.querySelector(`.chk_antitop[data-tab-idx='${tabIdx}']`);
        if (chk) chk.checked = false;
        applyTableFilters(tabIdx);
        setTimeout(() => fitAndHideColumns(tabIdx), 50);
    }

    function toggleDimMode(button) {
        document.body.classList.toggle('dim');
        button.textContent = document.body.classList.contains('dim') ? '💡 Светлее' : '🌙 Затемнить';
        Object.keys(activeCharts).forEach(chartId => {
            const tabIdxForChart = chartId.split('_').pop();
            const pageElement = document.getElementById(`tab${tabIdxForChart}`);
            if (pageElement && pageElement.style.display === 'block') {
                const kpiKlsMatch = pageElement.querySelector('.tbl')?.className.match(/tbl-kpi-([a-zA-Z0-9_]+)/);
                if (kpiKlsMatch && (kpiKlsMatch[1] === 'anti_top_year' || kpiKlsMatch[1] === 'monthly_anti_top')) {
                    // Если updateAntiTopCharts закомментирована, эта строка вызовет ошибку или ничего не сделает
                     updateAntiTopCharts(tabIdxForChart);
                }
            }
        });
    }
</script>
</body></html>
"""
